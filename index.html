<!DOCTYPE html>
<html lang="it">
<head>
    <title>Nation Pixel Project</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        h1 { color: #333; }
        #map { width: 80%; height: 600px; margin: 20px auto; border: 1px solid #ccc; }
        .leaflet-popup-content { text-align: center; }
        button { padding: 5px 10px; margin-top: 10px; cursor: pointer; }
        .logo-preview { max-width: 100px; max-height: 100px; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>Compra una Nazione!</h1>
    <p>Acquista una nazione e carica il tuo logo.</p>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="nations.js"></script>
    <script>
        var map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data © OpenStreetMap contributors'
        }).addTo(map);

        function calculatePixels(area) {
            return Math.ceil(area / 100); // 1 pixel = 100 km²
        }

        // Oggetto per tenere traccia delle nazioni acquistate
        let purchasedNations = JSON.parse(localStorage.getItem('purchasedNations')) || {};
        let logoLayers = {}; // Per tenere traccia degli overlay dei loghi
        const MAX_PURCHASES = 5; // Limite temporaneo di nazioni acquistabili

        // Funzione per salvare lo stato delle nazioni
        function savePurchasedNations() {
            try {
                localStorage.setItem('purchasedNations', JSON.stringify(purchasedNations));
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    alert('Spazio in localStorage esaurito! Prova a rimuovere alcune nazioni.');
                }
            }
        }

        // Funzione per comprimere l'immagine
        function compressImage(src, callback) {
            const img = new Image();
            img.src = src;
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const maxSize = 200; // Ridimensiona a 200x200 max
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > maxSize) {
                        height = Math.round((height * maxSize) / width);
                        width = maxSize;
                    }
                } else {
                    if (height > maxSize) {
                        width = Math.round((width * maxSize) / height);
                        height = maxSize;
                    }
                }

                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                callback(canvas.toDataURL('image/jpeg', 0.6)); // Qualità 60%
            };
        }

        // Funzione per convertire GeoJSON in SVG path per clip-path
        function geojsonToClipPath(geojson) {
            let pathData = '';
            const coordinates = geojson.coordinates;

            if (geojson.type === 'Polygon') {
                coordinates.forEach(polygon => {
                    polygon.forEach((point, index) => {
                        const latlng = L.latLng(point[1], point[0]);
                        const pixelPoint = map.latLngToLayerPoint(latlng);
                        pathData += (index === 0 ? 'M' : 'L') + `${pixelPoint.x},${pixelPoint.y}`;
                    });
                    pathData += 'Z';
                });
            } else if (geojson.type === 'MultiPolygon') {
                coordinates.forEach(multi => {
                    multi.forEach(polygon => {
                        polygon.forEach((point, index) => {
                            const latlng = L.latLng(point[1], point[0]);
                            const pixelPoint = map.latLngToLayerPoint(latlng);
                            pathData += (index === 0 ? 'M' : 'L') + `${pixelPoint.x},${pixelPoint.y}`;
                        });
                        pathData += 'Z';
                    });
                });
            }
            return pathData;
        }

        // Funzione per creare o aggiornare l'overlay del logo
        function updateLogoOverlay(name, geometry, logoSrc) {
            if (logoLayers[name]) {
                map.removeLayer(logoLayers[name]);
            }

            const bounds = L.geoJSON(geometry).getBounds();
            const pathData = geojsonToClipPath(geometry);

            const svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            svgElement.setAttribute('viewBox', '0 0 1000 1000');

            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', `clip-${name}`);
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            clipPath.appendChild(path);
            defs.appendChild(clipPath);
            svgElement.appendChild(defs);

            const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            image.setAttribute('href', logoSrc);
            image.setAttribute('width', '1000');
            image.setAttribute('height', '1000');
            image.setAttribute('preserveAspectRatio', 'xMidYMid slice');
            image.setAttribute('clip-path', `url(#clip-${name})`);
            svgElement.appendChild(image);

            logoLayers[name] = L.svgOverlay(svgElement, bounds).addTo(map);
        }

        fetch('custom.geo.json')
            .then(response => {
                if (!response.ok) throw new Error('Errore nel caricamento del JSON');
                return response.json();
            })
            .then(data => {
                L.geoJSON(data, {
                    style: function(feature) {
                        var name = feature.properties.name;
                        var isPurchased = purchasedNations[name] && purchasedNations[name].purchased;
                        return {
                            color: "#ff7800",
                            weight: 1,
                            fillOpacity: isPurchased ? 0 : 0.5,
                            fillColor: "#ff7800"
                        };
                    },
                    onEachFeature: function(feature, layer) {
                        var name = feature.properties.name || "Nazione sconosciuta";
                        var area = nationData[name] || 1000;
                        var pixels = calculatePixels(area);
                        var isPurchased = purchasedNations[name] && purchasedNations[name].purchased;

                        // Contenuto del popup
                        var popupContent = `
                            <b>${name}</b><br>
                            Pixel: ${pixels}<br>
                            Costo: $${pixels}<br>
                            Stato: ${isPurchased ? 'Acquistata' : 'Disponibile'}
                        `;
                        if (!isPurchased) {
                            const purchasedCount = Object.keys(purchasedNations).length;
                            if (purchasedCount >= MAX_PURCHASES) {
                                popupContent += `
                                    <br><p style="color: red;">Hai raggiunto il limite di ${MAX_PURCHASES} nazioni acquistabili. Rimuovi alcune nazioni per acquistarne altre.</p>
                                `;
                            } else {
                                popupContent += `
                                    <br><button onclick="buyNation('${name}', ${pixels})">Compra</button>
                                `;
                            }
                        } else if (purchasedNations[name].logo) {
                            popupContent += `
                                <br><img src="${purchasedNations[name].logo}" class="logo-preview" alt="Logo">
                                <br><button onclick="changeLogo('${name}')">Cambia Logo</button>
                                <br><button onclick="removeLogo('${name}')">Rimuovi Logo</button>
                            `;
                        } else {
                            popupContent += `
                                <br><button onclick="changeLogo('${name}')">Carica Logo</button>
                            `;
                        }

                        layer.bindPopup(popupContent);

                        // Se la nazione è acquistata e ha un logo, aggiungi l'overlay
                        if (isPurchased && purchasedNations[name].logo) {
                            updateLogoOverlay(name, feature.geometry, purchasedNations[name].logo);
                        }
                    }
                }).addTo(map);
            })
            .catch(error => console.error('Errore:', error));

        // Funzione per "comprare" una nazione
        function buyNation(name, pixels) {
            if (confirm(`Vuoi comprare ${name} per $${pixels}?`)) {
                purchasedNations[name] = { purchased: true, logo: null };
                savePurchasedNations();
                alert('Nazione acquistata! Ora puoi caricare un logo.');
                changeLogo(name);
            }
        }

        // Funzione per caricare o cambiare il logo
        function changeLogo(name) {
            var input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(event) {
                var file = event.target.files[0];
                if (file) {
                    var reader = new FileReader();
                    reader.onload = function(e) {
                        compressImage(e.target.result, function(compressedSrc) {
                            purchasedNations[name].logo = compressedSrc;
                            savePurchasedNations();
                            alert('Logo caricato con successo!');
                            fetch('custom.geo.json')
                                .then(response => response.json())
                                .then(data => {
                                    const feature = data.features.find(f => f.properties.name === name);
                                    if (feature) {
                                        updateLogoOverlay(name, feature.geometry, compressedSrc);
                                    }
                                });
                        });
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }

        // Funzione per rimuovere il logo
        function removeLogo(name) {
            if (confirm(`Vuoi rimuovere il logo e liberare la nazione ${name}?`)) {
                if (logoLayers[name]) {
                    map.removeLayer(logoLayers[name]);
                    delete logoLayers[name];
                }
                delete purchasedNations[name];
                savePurchasedNations();
                alert('Logo rimosso e nazione liberata!');
                location.reload();
            }
        }

        // Aggiorna gli overlay quando la mappa si muove
        map.on('moveend', function() {
            Object.keys(logoLayers).forEach(name => {
                fetch('custom.geo.json')
                    .then(response => response.json())
                    .then(data => {
                        const feature = data.features.find(f => f.properties.name === name);
                        if (feature && purchasedNations[name].logo) {
                            updateLogoOverlay(name, feature.geometry, purchasedNations[name].logo);
                        }
                    });
            });
        });
    </script>
</body>
</html>
